{
"version":3,
"file":"goog.dom.animationframe.animationframe.js",
"lineCount":82,
"mappings":"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",
"sources":["goog/dom/animationframe/animationframe.js"],
"sourcesContent":["// Copyright 2014 The Closure Library Authors. All Rights Reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS-IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n/**\n * @fileoverview goog.dom.animationFrame permits work to be done in-sync with\n * the render refresh rate of the browser and to divide work up globally based\n * on whether the intent is to measure or to mutate the DOM. The latter avoids\n * repeated style recalculation which can be really slow.\n *\n * Goals of the API:\n * <ul>\n *   <li>Make it easy to schedule work for the next animation frame.\n *   <li>Make it easy to only do work once per animation frame, even if two\n *       events fire that trigger the same work.\n *   <li>Make it easy to do all work in two phases to avoid repeated style\n *       recalculation caused by interleaved reads and writes.\n *   <li>Avoid creating closures per schedule operation.\n * </ul>\n *\n *\n * Programmatic:\n * <pre>\n * let animationTask = goog.dom.animationFrame.createTask(\n *     {\n *       measure: function(state) {\n *         state.width = goog.style.getSize(elem).width;\n *         this.animationTask();\n *       },\n *       mutate: function(state) {\n *         goog.style.setWidth(elem, Math.floor(state.width / 2));\n *       },\n *     },\n *     this);\n * </pre>\n *\n * See also\n * https://developer.mozilla.org/en-US/docs/Web/API/window.requestAnimationFrame\n */\n\ngoog.provide('goog.dom.animationFrame');\ngoog.provide('goog.dom.animationFrame.Spec');\ngoog.provide('goog.dom.animationFrame.State');\n\ngoog.require('goog.dom.animationFrame.polyfill');\n\n// Install the polyfill.\ngoog.dom.animationFrame.polyfill.install();\n\n\n/**\n * @typedef {{\n *   id: number,\n *   fn: !Function,\n *   context: (!Object|undefined)\n * }}\n * @private\n */\ngoog.dom.animationFrame.Task_;\n\n\n/**\n * @typedef {{\n *   measureTask: goog.dom.animationFrame.Task_,\n *   mutateTask: goog.dom.animationFrame.Task_,\n *   state: (!Object|undefined),\n *   args: (!Array|undefined),\n *   isScheduled: boolean\n * }}\n * @private\n */\ngoog.dom.animationFrame.TaskSet_;\n\n\n/**\n * @typedef {{\n *   measure: (!Function|undefined),\n *   mutate: (!Function|undefined)\n * }}\n */\ngoog.dom.animationFrame.Spec;\n\n\n\n/**\n * A type to represent state. Users may add properties as desired.\n * @constructor\n * @final\n */\ngoog.dom.animationFrame.State = function() {};\n\n\n/**\n * Saves a set of tasks to be executed in the next requestAnimationFrame phase.\n * This list is initialized once before any event firing occurs. It is not\n * affected by the fired events or the requestAnimationFrame processing (unless\n * a new event is created during the processing).\n * @private {!Array<!Array<goog.dom.animationFrame.TaskSet_>>}\n */\ngoog.dom.animationFrame.tasks_ = [[], []];\n\n\n/**\n * Values are 0 or 1, for whether the first or second array should be used to\n * lookup or add tasks.\n * @private {number}\n */\ngoog.dom.animationFrame.doubleBufferIndex_ = 0;\n\n\n/**\n * Whether we have already requested an animation frame that hasn't happened\n * yet.\n * @private {boolean}\n */\ngoog.dom.animationFrame.requestedFrame_ = false;\n\n\n/**\n * Counter to generate IDs for tasks.\n * @private {number}\n */\ngoog.dom.animationFrame.taskId_ = 0;\n\n\n/**\n * Whether the animationframe runTasks_ loop is currently running.\n * @private {boolean}\n */\ngoog.dom.animationFrame.running_ = false;\n\n\n/**\n * Returns a function that schedules the two passed-in functions to be run upon\n * the next animation frame. Calling the function again during the same\n * animation frame does nothing.\n *\n * The function under the \"measure\" key will run first and together with all\n * other functions scheduled under this key and the function under \"mutate\" will\n * run after that.\n *\n * @param {{\n *   measure: (function(this:THIS, !goog.dom.animationFrame.State)|undefined),\n *   mutate: (function(this:THIS, !goog.dom.animationFrame.State)|undefined)\n * }} spec\n * @param {THIS=} opt_context Context in which to run the function.\n * @return {function(...?)}\n * @template THIS\n */\ngoog.dom.animationFrame.createTask = function(spec, opt_context) {\n  var id = goog.dom.animationFrame.taskId_++;\n  var measureTask = {id: id, fn: spec.measure, context: opt_context};\n  var mutateTask = {id: id, fn: spec.mutate, context: opt_context};\n\n  var taskSet = {\n    measureTask: measureTask,\n    mutateTask: mutateTask,\n    state: {},\n    args: undefined,\n    isScheduled: false\n  };\n\n  return function() {\n    // Save args and state.\n    if (arguments.length > 0) {\n      // The state argument goes last. That is kinda horrible but compatible\n      // with {@see wiz.async.method}.\n      if (!taskSet.args) {\n        taskSet.args = [];\n      }\n      taskSet.args.length = 0;\n      taskSet.args.push.apply(taskSet.args, arguments);\n      taskSet.args.push(taskSet.state);\n    } else {\n      if (!taskSet.args || taskSet.args.length == 0) {\n        taskSet.args = [taskSet.state];\n      } else {\n        taskSet.args[0] = taskSet.state;\n        taskSet.args.length = 1;\n      }\n    }\n    if (!taskSet.isScheduled) {\n      taskSet.isScheduled = true;\n      var tasksArray = goog.dom.animationFrame\n                           .tasks_[goog.dom.animationFrame.doubleBufferIndex_];\n      tasksArray.push(\n          /** @type {goog.dom.animationFrame.TaskSet_} */ (taskSet));\n    }\n    goog.dom.animationFrame.requestAnimationFrame_();\n  };\n};\n\n\n/**\n * Run scheduled tasks.\n * @private\n */\ngoog.dom.animationFrame.runTasks_ = function() {\n  goog.dom.animationFrame.running_ = true;\n  goog.dom.animationFrame.requestedFrame_ = false;\n  var tasksArray = goog.dom.animationFrame\n                       .tasks_[goog.dom.animationFrame.doubleBufferIndex_];\n  var taskLength = tasksArray.length;\n\n  // During the runTasks_, if there is a recursive call to queue up more\n  // task(s) for the next frame, we use double-buffering for that.\n  goog.dom.animationFrame.doubleBufferIndex_ =\n      (goog.dom.animationFrame.doubleBufferIndex_ + 1) % 2;\n\n  var task;\n\n  // Run all the measure tasks first.\n  for (var i = 0; i < taskLength; ++i) {\n    task = tasksArray[i];\n    var measureTask = task.measureTask;\n    task.isScheduled = false;\n    if (measureTask.fn) {\n      // TODO (perumaal): Handle any exceptions thrown by the lambda.\n      measureTask.fn.apply(measureTask.context, task.args);\n    }\n  }\n\n  // Run the mutate tasks next.\n  for (var i = 0; i < taskLength; ++i) {\n    task = tasksArray[i];\n    var mutateTask = task.mutateTask;\n    task.isScheduled = false;\n    if (mutateTask.fn) {\n      // TODO (perumaal): Handle any exceptions thrown by the lambda.\n      mutateTask.fn.apply(mutateTask.context, task.args);\n    }\n\n    // Clear state for next vsync.\n    task.state = {};\n  }\n\n  // Clear the tasks array as we have finished processing all the tasks.\n  tasksArray.length = 0;\n  goog.dom.animationFrame.running_ = false;\n};\n\n\n/**\n * @return {boolean} Whether the animationframe is currently running. For use\n *     by callers who need not to delay tasks scheduled during runTasks_ for an\n *     additional frame.\n */\ngoog.dom.animationFrame.isRunning = function() {\n  return goog.dom.animationFrame.running_;\n};\n\n\n/**\n * Request {@see goog.dom.animationFrame.runTasks_} to be called upon the\n * next animation frame if we haven't done so already.\n * @private\n */\ngoog.dom.animationFrame.requestAnimationFrame_ = function() {\n  if (goog.dom.animationFrame.requestedFrame_) {\n    return;\n  }\n  goog.dom.animationFrame.requestedFrame_ = true;\n  window.requestAnimationFrame(goog.dom.animationFrame.runTasks_);\n};\n"],
"names":["goog","provide","require","dom","animationFrame","polyfill","install","Task_","TaskSet_","Spec","State","goog.dom.animationFrame.State","tasks_","doubleBufferIndex_","requestedFrame_","taskId_","running_","createTask","goog.dom.animationFrame.createTask","spec","opt_context","id","measureTask","fn","measure","context","mutateTask","mutate","taskSet","state","args","undefined","isScheduled","arguments","length","push","apply","tasksArray","requestAnimationFrame_","runTasks_","goog.dom.animationFrame.runTasks_","taskLength","task","i","isRunning","goog.dom.animationFrame.isRunning","goog.dom.animationFrame.requestAnimationFrame_","window","requestAnimationFrame"]
}
